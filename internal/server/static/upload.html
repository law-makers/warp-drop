<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>~/warp/drop</title>
    <style>
      :root {
        /* ANSI Color Map */
        --bg: #000000;
        --c-reset: #e5e5e5;
        --c-bold: #ffffff;
        --c-dim: #555555;
        --c-green: #00ff41;
        --c-yellow: #f1c40f;
        --c-magenta: #ff00ff;
        --c-red: #ff5555;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", Courier, "Lucida Console", monospace;
        background: var(--bg);
        color: var(--c-reset);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        line-height: 1.4;
      }

      .terminal {
        width: 100%;
        max-width: 600px;
      }

      /* Typography & Layout */
      h1 {
        font-size: 1rem;
        color: var(--c-magenta);
        font-weight: normal;
        margin-bottom: 1rem;
      }

      .prompt::before {
        content: "user@warp:~$ ";
        color: var(--c-green);
      }

      .subtitle {
        color: var(--c-dim);
        font-size: 0.85rem;
        margin-bottom: 1.5rem;
        display: block;
      }

      /* Upload Zone - styled as a defined memory block */
      .upload-zone {
        border: 1px dashed var(--c-dim);
        padding: 2rem 1rem;
        text-align: center;
        cursor: pointer;
        margin-bottom: 1.5rem;
        position: relative;
        transition: all 0.1s;
      }

      .upload-zone:hover,
      .upload-zone.dragover {
        border-color: var(--c-green);
        background: rgba(0, 255, 65, 0.05);
      }

      .upload-zone.dragover::after {
        content: "[ DROP_INCOMING_DATA ]";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg);
        color: var(--c-green);
        padding: 0.5rem;
      }

      .icon-ascii {
        display: block;
        color: var(--c-dim);
        margin-bottom: 1rem;
        white-space: pre;
        font-size: 0.7rem;
        line-height: 1;
        font-weight: bold;
      }

      .upload-text {
        color: var(--c-bold);
        font-size: 0.9rem;
      }

      .upload-hint {
        color: var(--c-dim);
        font-size: 0.75rem;
        margin-top: 0.5rem;
      }

      input[type="file"] {
        display: none;
      }

      /* File List - Styled as `ls -l` output */
      .file-list {
        margin-bottom: 1.5rem;
        border-top: 1px solid var(--c-dim);
        padding-top: 1rem;
      }

      .file-item {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 1rem;
        font-size: 0.85rem;
      }

      .file-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
        margin-bottom: 0.25rem;
      }

      .file-name {
        color: var(--c-reset);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        min-width: 0;
      }

      .file-size {
        color: var(--c-dim);
      }

      .file-actions {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-shrink: 0;
      }

      .remove-btn {
        background: none;
        border: none;
        color: var(--c-red);
        cursor: pointer;
        font-family: inherit;
        font-size: 1rem;
      }
      .remove-btn:hover {
        background: var(--c-red);
        color: var(--bg);
      }

      .action-btn {
        background: none;
        border: none;
        color: var(--c-magenta);
        cursor: pointer;
        font-family: inherit;
        font-size: 0.85rem;
        padding: 0.35rem 0.55rem;
        min-width: 2.2rem;
      }
      .action-btn:hover:not(:disabled) {
        background: var(--c-magenta);
        color: var(--bg);
      }
      .action-btn:disabled { color: var(--c-dim); border-color: var(--c-dim); }

      /* Progress Bar - Blocky style */
      .progress-container {
        width: 100%;
        height: 12px;
        background: var(--c-dim);
        margin-top: 2px;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: var(--c-green);
        width: 0%;
        transition: width 0.2s linear;
      }

      .speed-text {
        color: var(--c-yellow);
        font-size: 0.75rem;
        margin-top: 4px;
        text-align: right;
        width: 100%;
        display: block;
      }

      /* Actions */
      .btn {
        width: 100%;
        background: transparent;
        color: var(--c-green);
        border: 1px solid var(--c-green);
        padding: 1rem;
        font-family: inherit;
        font-size: 1rem;
        cursor: pointer;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 1px;
      }

      .btn:hover:not(:disabled) {
        background: var(--c-green);
        color: var(--bg);
      }

      .btn:disabled {
        border-color: var(--c-dim);
        color: var(--c-dim);
        cursor: not-allowed;
      }

      /* Footer */
      .footer {
        margin-top: 2rem;
        border-top: 1px solid var(--c-dim);
        padding-top: 0.5rem;
        font-size: 0.75rem;
        color: var(--c-dim);
        display: flex;
        justify-content: space-between;
      }

      /* Blinking Cursor Utility */
      .cursor::after {
        content: "â–ˆ";
        animation: blink 1s step-end infinite;
        color: var(--c-green);
        margin-left: 5px;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="terminal">
      <h1 class="prompt">./warp_drop --secure</h1>
      <span class="subtitle"
        >// Transfer files securely via raw stream. No caching.</span
      >

      <form method="POST" enctype="multipart/form-data" id="uploadForm">
        <div class="upload-zone" id="dropZone">
          <div class="icon-ascii">| --+-- |</div>
          <div class="upload-text">[ SELECT OR DRAG FILES ]</div>
          <div class="upload-hint">>> awaiting input stream...</div>
        </div>

        <input type="file" name="file" id="fileInput" multiple required />

        <div class="file-list" id="fileList"></div>

        <button type="submit" class="btn" id="submitBtn" disabled>
          [ INITIALIZE UPLOAD ]
        </button>
      </form>

      <div class="footer">
        <span>STATUS: IDLE</span>
        <span class="cursor">_</span>
      </div>
    </div>

    <script>
      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const fileList = document.getElementById("fileList");
      const submitBtn = document.getElementById("submitBtn");
      const footerStatus = document.querySelector(".footer span:first-child");
      const cursorEl = document.querySelector(".cursor");
      let serverAlive = true;
      let uploadInProgress = false;
      let selectedFiles = [];
      const uploads = {}; // per-file state
      const manifestDefaults = { chunkSize: 2 * 1024 * 1024, maxConcurrent: 3 };
      let manifestConfig = { ...manifestDefaults };

      // Interaction Logic
      dropZone.addEventListener("click", () => fileInput.click());

      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      ["dragenter", "dragover", "dragleave", "drop"].forEach((evt) => {
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });

      ["dragenter", "dragover"].forEach((evt) => {
        dropZone.addEventListener(evt, () =>
          dropZone.classList.add("dragover"),
        );
      });

      ["dragleave", "drop"].forEach((evt) => {
        dropZone.addEventListener(evt, () =>
          dropZone.classList.remove("dragover"),
        );
      });

      dropZone.addEventListener("drop", (e) => {
        const files = e.dataTransfer.files;
        handleFiles(files);
      });

      function handleFiles(files) {
        selectedFiles = Array.from(files);
        for (const key of Object.keys(uploads)) delete uploads[key];
        updateFileList();
        submitBtn.disabled = selectedFiles.length === 0;
        if (selectedFiles.length > 0) {
          footerStatus.textContent =
            "STATUS: " + selectedFiles.length + " FILES STAGED";
          footerStatus.style.color = "var(--c-bold)";
        } else {
          footerStatus.textContent = "STATUS: IDLE";
          footerStatus.style.color = "var(--c-dim)";
        }
      }

      function updateFileList() {
        if (selectedFiles.length === 0) {
          fileList.innerHTML = "";
          return;
        }
        const items = [];
        for (let i = 0; i < selectedFiles.length; i++) {
          const f = selectedFiles[i];
          items.push(
            `<div class="file-item">
        <div class="file-header">
          <span class="file-name">./${escapeHtml(f.name)}</span>
          <div class="file-actions">
            <span class="file-size">${formatSize(f.size)}</span>
            <button type="button" id="toggle-${i}" class="action-btn" onclick="toggleUpload(${i})">[>]</button>
            <button type="button" class="remove-btn" onclick="cancelUpload(${i})">[x]</button>
          </div>
        </div>
        <div class="progress-container">
          <div id="bar-${i}" class="progress-bar"></div>
        </div>
        <span id="speed-${i}" class="speed-text">WAITING...</span>
      </div>`,
          );
        }
        fileList.innerHTML = items.join("");
      }

      function removeFile(idx) {
        const st = uploads[idx];
        if (st && st.xhrs) {
          st.paused = true;
          for (const xhr of st.xhrs.values()) xhr.abort();
          st.xhrs.clear();
        }
        delete uploads[idx];
        selectedFiles.splice(idx, 1);
        const dt = new DataTransfer();
        selectedFiles.forEach((file) => dt.items.add(file));
        fileInput.files = dt.files;
        updateFileList();
        submitBtn.disabled = selectedFiles.length === 0;
        if (selectedFiles.length === 0) {
          footerStatus.textContent = "STATUS: IDLE";
        }
      }

      function formatSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1048576) return (bytes / 1024).toFixed(1) + " KB";
        return (bytes / 1048576).toFixed(1) + " MB";
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Upload Logic
      const form = document.getElementById("uploadForm");
      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        uploadInProgress = true;
        submitBtn.disabled = true;
        submitBtn.textContent = "[ UPLOAD IN PROGRESS... ]";
        footerStatus.textContent = "STATUS: UPLOADING...";
        footerStatus.style.color = "var(--c-yellow)";
        for (let i = 0; i < selectedFiles.length; i++) {
          await startUpload(i);
        }
        submitBtn.textContent = "[ PROCESS COMPLETE ]";
        footerStatus.textContent = "STATUS: DONE";
        footerStatus.style.color = "var(--c-green)";
        uploadInProgress = false;
      });

      async function startUpload(idx) {
        const file = selectedFiles[idx];
        if (!file) return;
        if (!uploads[idx]) {
          const chunkSize = manifestConfig.chunkSize || manifestDefaults.chunkSize;
          const totalChunks = Math.max(1, Math.ceil(file.size / chunkSize));
          const pending = [];
          for (let c = 0; c < totalChunks; c++) pending.push(c);
          uploads[idx] = {
            paused: false,
            running: false,
            chunkSize,
            maxConcurrent: manifestConfig.maxConcurrent || manifestDefaults.maxConcurrent,
            pending,
            inFlight: new Set(),
            xhrs: new Map(),
            completedBytes: 0,
            total: file.size,
          };
        }
        const st = uploads[idx];
        if (st.running && !st.paused) return;
        st.paused = false;
        st.running = true;
        setToggleIcon(idx, true);
        scheduleChunks(idx);
      }

      function pauseUpload(idx) {
        const st = uploads[idx];
        if (!st) return;
        st.paused = true;
        setToggleIcon(idx, false);
        for (const xhr of st.xhrs.values()) {
          xhr.abort();
        }
        st.xhrs.clear();
        const sp = document.getElementById("speed-" + idx);
        if (sp) {
          sp.textContent = "PAUSED";
          sp.style.color = "var(--c-yellow)";
        }
      }

      function toggleUpload(idx) {
        const st = uploads[idx];
        if (st && st.running && !st.paused) {
          pauseUpload(idx);
        } else {
          startUpload(idx);
        }
      }

      function setToggleIcon(idx, playing) {
        const btn = document.getElementById("toggle-" + idx);
        if (btn) btn.textContent = playing ? "[||]" : "[>]";
      }

      function scheduleChunks(idx) {
        const file = selectedFiles[idx];
        const st = uploads[idx];
        if (!file || !st) return;
        if (st.paused) return;

        while (!st.paused && st.inFlight.size < st.maxConcurrent && st.pending.length > 0) {
          const chunkId = st.pending.shift();
          st.inFlight.add(chunkId);
          const start = chunkId * st.chunkSize;
          const end = Math.min(start + st.chunkSize, file.size);
          const chunk = file.slice(start, end);
          const xhr = sendChunk(idx, file, chunk, start, chunkId);
          st.xhrs.set(chunkId, xhr);
          xhr.promise
            .then((result) => {
              st.inFlight.delete(chunkId);
              st.xhrs.delete(chunkId);
              if (result && result.aborted) {
                st.pending.unshift(chunkId);
                return;
              }
              st.completedBytes += chunk.size;
              updateProgress(idx);
              if (st.completedBytes >= file.size) {
                finishUpload(idx);
              } else {
                scheduleChunks(idx);
              }
            })
            .catch(() => {
              st.inFlight.delete(chunkId);
              st.xhrs.delete(chunkId);
              st.pending.unshift(chunkId);
              pauseUpload(idx);
              const sp = document.getElementById("speed-" + idx);
              if (sp) { sp.textContent = "ERROR"; sp.style.color = "red"; }
            });
        }
      }

      function updateProgress(idx) {
        const st = uploads[idx];
        const file = selectedFiles[idx];
        if (!st || !file) return;
        const pct = Math.min(100, (st.completedBytes / file.size) * 100);
        const bar = document.getElementById("bar-" + idx);
        if (bar) bar.style.width = pct.toFixed(1) + "%";
        const sp = document.getElementById("speed-" + idx);
        if (sp) sp.textContent = `[ ${pct.toFixed(0)}% ]`;
      }

      function finishUpload(idx) {
        const sp = document.getElementById("speed-" + idx);
        if (sp) {
          sp.textContent = "UPLOAD_COMPLETE";
          sp.style.color = "var(--c-green)";
        }
        setToggleIcon(idx, false);
        const st = uploads[idx];
        if (st) {
          st.running = false;
          st.paused = false;
        }
      }

      function sendChunk(idx, file, chunk, offset, chunkId) {
        const xhr = new XMLHttpRequest();
        const promise = new Promise((resolve, reject) => {
          xhr.open("POST", window.location.pathname.replace(/\/$/, ""));
          xhr.setRequestHeader("X-File-Name", encodeURIComponent(file.name));
          xhr.setRequestHeader("X-Upload-Offset", String(offset));
          xhr.setRequestHeader("X-Upload-Total", String(file.size));
          xhr.setRequestHeader("X-Chunk-Id", String(chunkId));
          xhr.setRequestHeader("X-Chunk-Total", String(Math.ceil(file.size / (uploads[idx]?.chunkSize || manifestDefaults.chunkSize))));
          xhr.onabort = function () {
            resolve({ aborted: true });
          };
          xhr.onerror = function () {
            reject(new Error("network error"));
          };
          xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status >= 200 && xhr.status < 300) {
                resolve({});
              } else {
                reject(new Error("chunk failed"));
              }
            }
          };
          xhr.send(chunk);
        });
        xhr.promise = promise;
        return xhr;
      }

      function cancelUpload(idx) {
        const st = uploads[idx];
        if (st) {
          st.paused = true;
          for (const xhr of st.xhrs.values()) xhr.abort();
          st.xhrs.clear();
        }
        removeFile(idx);
      }

      // Health Polling: update status to DISCONNECTED when server is down
      async function pollHealth() {
        try {
          const res = await fetch("/health", { cache: "no-store" });
          if (res.ok) {
            serverAlive = true;
            if (cursorEl) cursorEl.style.color = "var(--c-green)";
            // If nothing staged or uploading, reflect IDLE
            if (selectedFiles.length === 0 && !uploadInProgress) {
              footerStatus.textContent = "STATUS: IDLE";
              footerStatus.style.color = "var(--c-dim)";
            }
          } else {
            throw new Error("bad status");
          }
        } catch (e) {
          serverAlive = false;
          if (cursorEl) cursorEl.style.color = "var(--c-red)";
          // Only override when no ongoing activity
          if (selectedFiles.length === 0 && !uploadInProgress) {
            footerStatus.textContent = "STATUS: DISCONNECTED";
            footerStatus.style.color = "var(--c-dim)";
          }
        }
      }

      async function loadManifest() {
        try {
          const res = await fetch(window.location.pathname.replace(/\/$/, "") + "/manifest", { cache: "no-store" });
          if (!res.ok) throw new Error("bad status");
          const data = await res.json();
          manifestConfig = {
            chunkSize: data.chunk_size || manifestDefaults.chunkSize,
            maxConcurrent: data.max_concurrent || manifestDefaults.maxConcurrent,
          };
        } catch (e) {
          manifestConfig = { ...manifestDefaults };
        }
      }

      // Start polling health every 2 seconds
      setInterval(pollHealth, 2000);
      // Initial check
      loadManifest().then(pollHealth);
    </script>
  </body>
</html>
